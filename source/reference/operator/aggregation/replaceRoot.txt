==========================
$replaceRoot (aggregation)
==========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Definition
----------

.. pipeline:: $replaceRoot

   .. versionadded:: 3.4
 
   Replaces the input document with the specified document. The
   operation replaces all existing fields in the input document,
   including the ``_id`` field. You can promote an existing
   embedded document to the top level, or create a new document
   for promotion (see
   :ref:`example<new-replacement-doc>`).

   .. note::

      Starting in version 4.2, MongoDB adds a new aggregation pipeline
      stage :pipeline:`$replaceWith` that is an alias for
      :pipeline:`$replaceRoot`.
   
   The :pipeline:`$replaceRoot` stage has the following form:
 
   .. code-block:: javascript
 
      { $replaceRoot: { newRoot: <replacementDocument> } }
 
   The replacement document can be any valid :ref:`expression
   <aggregation-expressions>` that resolves to a document. The stage
   errors and fails if ``<replacementDocument>`` is not a document. For
   more information on expressions, see :ref:`aggregation-expressions`.

Behavior
--------

If the ``<replacementDocument>`` is not a document,
:pipeline:`$replaceRoot` errors and fails.

If the ``<replacementDocument>`` refers to a field in the input
document that does not exist, :pipeline:`$replaceRoot` errors and
fails. For example, the following documents are input to the
:pipeline:`$replaceRoot` stage:

.. code-block:: javascript
   :copyable: false

   { "_id": 1, "name" : { "first" : "John", "last" : "Backus" } }
   { "_id": 2, "name" : { "first" : "John", "last" : "McCarthy" } }
   { "_id": 3, "name": { "first" : "Grace", "last" : "Hopper" } }
   { "_id": 4, "firstname": "Ole-Johan", "lastname" : "Dahl" }

Then the following :pipeline:`$replaceRoot` operation fails because one
of the document does not have the ``name`` field:

.. code-block:: javascript

   db.collection.aggregate([
      { $replaceRoot: { newRoot: "$name" } }
   ])

To ensure that the replacement document exists, use
a :pipeline:`$match` stage first to check for existence
before passing documents to the :pipeline:`$replaceRoot` stage:

.. code-block:: javascript

   db.collection.aggregate([
      { $match: { name : { $exists: true } } },
      { $replaceRoot: { newRoot: "$name" } }
   ])
   

Examples
--------

.. _replace-with-match:

``$replaceRoot`` with an Embedded Document Field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A collection named ``people`` contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "name" : "Arlene", "age" : 34, "pets" : { "dogs" : 2, "cats" : 1 } }
   { "_id" : 2, "name" : "Sam", "age" : 41, "pets" : { "cats" : 1, "hamsters" : 3 } }
   { "_id" : 3, "name" : "Maria", "age" : 25 }

The following operation promotes the ``pets`` embedded document to the
top level:

.. code-block:: javascript

   db.people.aggregate( [
      {
        $match: { pets : { $exists: true } }
      },
      {
        $replaceRoot: { newRoot: "$pets" }
      }
   ] )

First Stage:
   The :pipeline:`$match` stage filters out documents that do not
   contain the ``pets`` field or documents that contain a non-document
   ``pets`` field. Without this filter, if any document is passed into
   the :pipeline:`$replaceRoot` stage without the ``pets`` field or if
   the ``pets`` field is not a document, the aggregation errors.

Second Stage:
   The :pipeline:`$replaceRoot` stage replaces each input document with
   the ``pets`` document.

The operation returns the following results:

.. code-block:: javascript

   { "dogs" : 2, "cats" : 1 }
   { "cats" : 1, "hamsters" : 3 }

``$replaceRoot`` with a Document Nested in an Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A collection named ``contacts`` contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "name" : "Susan",
     "phones" : [ { "cell" : "555-653-6527" },
                  { "home" : "555-965-2454" } ] }
   { "_id" : 2, "name" : "Mark",
     "phones" : [ { "cell" : "555-445-8767" },
                  { "home" : "555-322-2774" } ] }

The following operation promotes the embedded document with key
``cell`` to the top level:

.. code-block:: javascript

   db.contacts.aggregate( [
      {
         $unwind: "$phones"
      },
      {
         $match: { "phones.cell" : { $exists: true } }
      },
      {
         $replaceRoot: { newRoot: "$phones"}
      }
   ] )

The operation returns the following results:

.. code-block:: javascript

   { "cell" : "555-653-6527" }
   { "cell" : "555-445-8767" }

.. _new-replacement-doc:

``$replaceRoot`` with a newly created document
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also create new documents as part of the
``$replaceRoot`` stage and use them to replace all the other fields.

A collection named ``contacts`` contains the following documents:

.. code-block:: javascript

   { "_id" : 1, "first_name" : "Gary", "last_name" : "Sheffield", "city" : "New York" }
   { "_id" : 2, "first_name" : "Nancy", "last_name" : "Walker", "city" : "Anaheim" }
   { "_id" : 3, "first_name" : "Peter", "last_name" : "Sumner", "city" : "Toledo" }

The following operation creates a new document out of the
``first_name`` and ``last_name`` fields.

.. code-block:: javascript

   db.contacts.aggregate( [
      {
         $replaceRoot: {
            newRoot: {
               full_name: {
                  $concat : [ "$first_name", " ", "$last_name" ]
               }
            }
         }
      }
   ] )

The operation returns the following results:

.. code-block:: javascript

   { "full_name" : "Gary Sheffield" }
   { "full_name" : "Nancy Walker" }
   { "full_name" : "Peter Sumner" }

