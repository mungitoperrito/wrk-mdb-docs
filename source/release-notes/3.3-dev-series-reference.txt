:orphan:

==================================
Development Series 3.3.x Reference
==================================

.. default-domain:: mongodb

.. include:: /includes/3.3-dev-series.rst

See also :doc:`/release-notes/3.3-dev-series`.

Aggregation Framework Enhancements
----------------------------------

New Stages
~~~~~~~~~~

MongoDB 3.3 development series introduces the following new
:ref:`aggregation pipeline stage <aggregation-pipeline>`.

.. pipeline:: $graphLookup

   Performs a recursive search on a collection. The stage matches the
   ``connectFromField`` of one document to the ``connectToField`` of
   other documents in the collection. Then, for any matching document,
   the :pipeline:`$graphLookup` uses the ``connectFromField`` of the
   matching document to match to the the ``connectToField`` of other
   documents, and continues until no new documents are encountered or
   until a specified depth. To each output document, the
   :pipeline:`$graphLookup` adds a new array field that contains the
   traversal results of the recursive search for that document.

   The :pipeline:`$graphLookup` stage has the following form:

   .. code-block:: javascript

      {
         $graphLookup: {
            from: <collection>,
            connectToField: <string>,
            startWith: <expression>,
            connectFromField: <string>,
            as: <string>,
            maxDepth: <number>,
            depthField: <string>,
            restrictSearchWithMatch: <document>
         }
      }

   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Field
        - Description

      * - ``from``

        - Collection on whose documents to perfrom
          :pipeline:`$graphLookup`, recursively matching on the
          ``connectFromField`` to the ``connectToField``.

          The ``from`` collection cannot not be sharded.

      * - ``connectFromField``

        - Field name whose value :pipeline:`$graphLookup` uses to
          recursively match against the ``connectToField`` of other
          documents in the collection.

      * - ``startWith``

        - Expression that specifies the value of the
          ``connectFromField`` with which to start the recursive
          search.

      * - ``connectToField``

        - Field name in other document against which to match the
          ``connectToField``.

      * - ``as``

        - Field name of the array field added to each output document
          that contains the documents traversed in the
          :pipeline:`$graphLookup` stage for the document.

      * - ``maxDepth``
        - Non-negative integral number that specifies the maximum
          recursive depth.

      * - ``depthField`` 

        - *Optional.* Name of the field to add to each traversed
          document in the search path. The field holds the recursion depth for
          the document. Depth value starts at zero; i.e. the first
          lookup corresponds to zero depth.

      * - ``restrictSearchWithMatch``

        - A document that specifies additional condition for the
          recursive search. The syntax is identical to the :ref:`query
          filter <read-operations-query-argument>` syntax.

   .. COMMENT to DocsTeam: Be sure to include an example using the 'restrictSearchByMatch'
   
   Consider a collection ``employees`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "name" : "Dev" }
      { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
      { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }
      { "_id" : 4, "name" : "Andrew", "reportsTo" : "Eliot" }
      { "_id" : 5, "name" : "Asya", "reportsTo" : "Ron" }
      { "_id" : 6, "name" : "Dan", "reportsTo" : "Andrew" }

   The following :pipeline:`$graphLookup` operation traverses the
   documents in the collection to recursively match on the
   ``reportsTo`` and ``name`` to return the reporting hierarchy for
   each person:

   .. code-block:: javascript

      db.employees.aggregate( [
         {
            $graphLookup: {
               from: "employees",
               startWith: "$reportsTo",
               connectFromField: "reportsTo",
               connectToField: "name",
               as: "reportingHierarchy"
            }
         }
      ] )
   
   The operation returns the following documetns:
   
   .. code-block:: javascript
   
      { "_id" : 1, "name" : "Dev", "reportingHierarchy" : [ ] }
      {
      
         "_id" : 2,
         "name" : "Eliot",
         "reportsTo" : "Dev",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" }
         ]
      }
      {
         "_id" : 3,
         "name" : "Ron",
         "reportsTo" : "Eliot",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
         ]
      }
      {
         "_id" : 4,
         "name" : "Andrew",
         "reportsTo" : "Eliot",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
         ]
      }
      {
         "_id" : 5,
         "name" : "Asya",
         "reportsTo" : "Ron",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" },
            { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }
         ]
      }
      {
         "_id" : 6,
         "name" : "Dan",
         "reportsTo" : "Andrew",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" },
            { "_id" : 4, "name" : "Andrew", "reportsTo" : "Eliot" }
         ]
      }

   The following table provides a traversal path for operation for the
   document ``{ "_id" : 5, "name" : "Asya", "reportsTo" : "Ron" }``:

   .. list-table::
      :stub-columns: 1

      * - Start value

        - The ``reportsTo`` value of the document:

          .. code-block:: javascript

             { ... "reportsTo" : "Ron" }

      * - Depth 0

        - .. code-block:: javascript

             { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }

      * - Depth 1

        - .. code-block:: javascript

             { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }

      * - Depth 2
         
        - .. code-block:: javascript

             { "_id" : 1, "name" : "Dev" }
   
   
   Similar to :pipeline:`$lookup`, :pipeline:`$graphLookup` can access
   another collection in the same database. For example, a database
   contains the following collections:

   - A collection ``airports`` that contains the following documents:

     .. code-block:: javascript

        { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ] }
        { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ] }
        { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ] }
        { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ] }
        { "_id" : 4, "airport" : "LHR", "connects" : [ "PWM" ] }

   - A collection ``travelers`` that contains the following documents:

     .. code-block:: javascript

        { "_id" : 1, "name" : "Dev", "nearestAirport" : "JFK" }
        { "_id" : 2, "name" : "Eliot", "nearestAirport" : "JFK" }
        { "_id" : 3, "name" : "Jeff", "nearestAirport" : "BOS" }

   For each document in the ``travelers`` collection, the following
   operation looks up a the ``nearestAirport`` value in the
   ``airports`` collection, and recursively matches the ``connects``
   field to the ``airport`` fields in documents in the ``airports``
   collection. The operation specifies a maximum number of recursion to
   ``2``.

   .. code-block:: javascript

      db.travelers.aggregate( [
         {
            $graphLookup: {
               from: "airports",
               startWith: "$nearestAirport",
               connectFromField: "connects",
               connectToField: "airport",
               maxDepth: 2,
               depthField: "numConnections",
               as: "destinations"
            }
         }
      ] )

   The operation returns the following results:
   
   .. code-block:: javascript
   
      {
         "_id" : 1,
         "name" : "Dev",
         "nearestAirport" : "JFK",
         "destinations" : [
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(2) },
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(1) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(0) }
         ] 
      }
      {
         "_id" : 2,
         "name" : "Eliot",
         "nearestAirport" : "JFK",
         "destinations" : [ 
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(2) },
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(1) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(0) } ]
      }
      {
         "_id" : 3,
         "name" : "Jeff",
         "nearestAirport" : "BOS",
         "destinations" : [
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(2) },
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(1) },
            { "_id" : 4, "airport" : "LHR", "connects" : [ "PWM" ], "numConnections" : NumberLong(2) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(0) }
         ]
      }
   
   The following table provides a traversal path for the recursive
   search, up to depth 2, where the starting ``airport`` is ``JFK``:

   .. list-table::
      :stub-columns: 1

      * - Start value

        - The ``nearestAirport`` value from the ``travelers`` collection:

          .. code-block:: javascript

             { ... "nearestAirport" : "JFK" }

      * - Depth 0

        - .. code-block:: javascript

             { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ] }

      * - Depth 1

        - .. code-block:: javascript

             { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ] }
             { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ] }
            
      * - Depth 2
         
        - .. code-block:: javascript

             { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ] }

   .. seealso:: :ref:`agg-memory-restrictions`

New Array Operators
~~~~~~~~~~~~~~~~~~~~

MongoDB 3.3 development series introduces the following new array
operators for the aggregation framework:

.. expression:: $in

   Returns a boolean that indicates if a specified value is in an array.

   :expression:`$in` has the following :ref:`operator expression syntax
   <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $in: [ <expression>, <array expression> ] }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.

   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Operand
        - Description

      * - ``<expression>`` 

        - Any valid expression :ref:`expression
          <aggregation-expressions>`.

      * - ``<array expression>`` 

        - Any valid :ref:`expression <aggregation-expressions>` that
          resolves to an array.

   Unlike the :query:`$in` query operator which can support
   :ref:`regular expressions <query-in-regex>` to match values, the
   aggregation :expression:`$in` operator does not support matching by
   :ref:`regular expressions <query-in-regex>`.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $in: [ 2, [ 1, 2, 3 ] ] }``
        - ``true``

      * - ``{ $in: [ "abc", [ "xyz", "abc" ] ] }``
        - ``true``

      * - ``{ $in: [ "xy", [ "xyz", "abc" ] ] }``
        - ``false``

      * - ``{ $in: [ ["a"], [ "a" ] ] }``
        - ``false``

      * - ``{ $in: [ ["a"], [ ["a"] ] ] }``
        - ``true``

      * - ``{ $in: [ /^a/, [ "a" ] ] }``
        - ``false``

      * - ``{ $in: [ /^a/, [ "a" ] ] }``
        - ``false``

      * - ``{ $in: [ /^a/, [ /^a/ ] ] }``
        - ``true``

.. expression:: $indexOfArray

   Searches an array for an occurence of a specified value and returns
   the array index (zero-based) of the first occurence. If the
   substring is not found, returns ``-1``.

   :expression:`$indexOfArray` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $indexOfArray: [ <array expression>, <search expression>, <start>, <end> ] }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
      
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work

   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``<array expression>``

        - Can be any valid :ref:`expression
          <aggregation-expressions>` as long as it resolves to an
          array. For more information on expressions, see
          :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-indexOfArray-string.rst

      * - ``<search expression>``
        - Can be any valid :ref:`expression
          <aggregation-expressions>`. For more information on expressions, see
          :ref:`aggregation-expressions`.

      * - ``<start>`` 

        - *Optional* An integral number that specifies the starting index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number.

      * - ``<end>`` 

        - *Optional* An integral number that specifies the ending index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number. If you specify a ``<end>`` index
          value, you should also specify a ``<start>`` index value;
          otherwise, :expression:`$indexOfArray` uses the ``<end>``
          value as the ``<start>`` index value instead of the ``<end>``
          value.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $indexOfArray: [ [ "a", "abc" ] , "a" ] }``
        - ``0``

      * - ``{ $indexOfArray: [ [ "a", "abc", "de", ["de"] ], ["de"] ] }``
        - ``3``

      * - ``{ $indexOfArray: [ [ 1, 2 ], 5 ] }``
        - ``-1``

      * - ``{ $indexOfArray: [ [ 10, 9, 9, 8, 9 ], 9, 3 ] }``
        - ``4``

      * - ``{ $indexOfArray: [ [ "a", "abc", "b" ] , "b", 0, 1 ] }``

        - ``-1``

   .. seealso:: :expression:`$in`

.. expression:: $range

   Returns an array whose elements are a generated sequence of numbers.
   The :expression:`$range` generates the sequence from the specified
   starting number by successively incrementing the starting number by
   the specified step value up to but not including the end point.

   :expression:`$range` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $range: [ <start>, <end>, <non-zero step> ] }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Operand
        - Description

      * - ``<start>`` 

        - An integral number that specifies the start of the sequence. Can be any
          valid expression :ref:`expression <aggregation-expressions>`
          that resolves to an integral number.

      * - ``<end>`` 

        - An integral number that specifies the upper limit (exclusive) of the
          sequence. Can be any valid expression :ref:`expression
          <aggregation-expressions>` that resolves to an integral number.

      * - ``<non-zero step>``

        - An integral number that specifies the increment value. Can be any
          valid expression :ref:`expression <aggregation-expressions>`
          that resolves to a non-zero integral number.

   .. list-table::
      :header-rows: 1
      :widths: 80 20 

      * - Example
        - Results


      * - ``{ $range: [ 0, 10, 2 ] }``
        - ``[ 0, 2, 4, 6, 8 ]``

      * - ``{ $range: [ 10, 0, -2 ] }``
        - ``[ 10, 8, 6, 4, 2 ]``

      * - ``{ $range: [ 0, 10, -2 ] }``
        - ``[ ]``

.. expression:: $reverseArray

   Takes an array and returns an output array whose elements are those
   of the input array but in reverse order.

   :expression:`$reverseArray` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $reverseArray: <array expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to an array. For
   more information on expressions, see :ref:`aggregation-expressions`.

   .. include:: /includes/extracts/agg-expression-null-operand-reverseArray.rst

   .. list-table::
      :header-rows: 1
      :widths: 80 20 

      * - Example
        - Results

      * - ``{ $reverseArray: [ 1, 2, 3 ] }``
        - ``[ 3, 2, 1 ]``

      * - ``{ $reverseArray: [ ] }``
        - ``[ ]``

      * - ``{ $reverseArray: null }``
        - ``null``


.. expression:: $reduce

   Takes an array as input and applies an expression to each element in
   the array to return the final result of the expression.

   :expression:`$reduce` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      {
          $reduce: {
              input: <array>,
              initialValue: <expression>,
              in: <expression>
          }
      }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.

   .. list-table::
      :header-rows: 1
      :widths: 30 70

      * - Operand
        - Description

      * - ``input``

        - Can be any valid :ref:`expression <aggregation-expressions>`
          as long as it resolves to an array. For more information on
          expressions, see :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-reduce.rst

      * - ``initialValue``

        - Initial value of the return value.

      * - ``in``
      
        - A valid :ref:`expression <aggregation-expressions>` to apply
          to each element in the ``input`` array. In the expression,
          
          - ``value`` is the :doc:`variable
            </reference/aggregation-variables>` that equals the
            cumulative value of the expression.
            
          - ``this`` is the :doc:`variable
            </reference/aggregation-variables>` that refers to the
            element being processed.

   .. list-table::
      :header-rows: 1
      :widths: 70 20 

      * - Example
        - Results

      * -  .. code-block:: javascript
              
              {
                 $reduce: {
                    input: ["a", "b", "c"],
                    initialValue: "",
                    in: { $concat : ["$$value", "$$this"] } 
                  }
              }

        - ``"abc"``

      * - .. code-block:: javascript
      
             { 
                $reduce: {
                   input: [ 0, 2 ],
                   initialValue: { sum: 0, product: 1 },
                   in: { 
                      sum: { $add : ["$$value.sum", "$$this"] },
                      product: { $multiply: [ "$$value.product", "$$this" ] }
                   }
                }
             }

        - ``{ "sum" : 2, "product" : 0 }``

.. expression:: $zip

   Returns an output array where each element is itself an array,
   consisting of elements in the corresponding array index position
   from the input arrays. That is, the first element in the output
   array is an array consisting of the first element from each of the
   input arrays.

   The input arrays do not need to be of the same length. By default,
   the length of the shortest input array determines the length of the
   output array, but you can also have the longest input array
   determine the output array.

   :expression:`$zip` has the following syntax:

   .. code-block:: javascript

      {
          $zip: {
              inputs: [ <array expression1>,  ... ],
              useLongestLength: <boolean>,
              defaults:  <array expression> 
          }
      }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.

   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``inputs``

        - An array of :ref:`expressions <aggregation-expressions>` that
          resolve to arrays. The elements of these arrays combine to
          form the array element of the output array.

          .. include:: /includes/extracts/agg-expression-null-operand-zip.rst

      * - ``useLongestLength``

        - A boolean which specifies whether the length of the longest
          array determines the number of elements in the output array.

          Default value is ``false``; i.e. the shortest array length
          determines the number of elements in the output array.

      * - ``defaults``

        - An array of default element values to use for *each* input
          array if the array index position exceeds the array length.
          Use in conjunction with ``useLongestLength: true``. 
          
          If ``useLongestLength: true`` and the ``defaults`` array is
          unspecified, :expression:`$zip` uses ``null`` as the default
          values.
          
          If specifying ``defaults``, you must specify a default for
          *each* input array.

          Invalid if ``useLongestLength`` is ``false``.

   .. list-table::
      :header-rows: 1
      :widths: 60 35

      * - Example
        - Results

      * - ``{ $zip: { inputs: [ [ 'a' ], [ 'b' ], [ 'c' ] ] }``
        - ``[ [ "a", "b", "c" ] ]``

      * - ``{ $zip: { inputs: [ [ 'a' ], [ 'b', 'c' ] ] } }``
        - ``[ [ "a", "b" ] ]``

      * - .. code-block:: javascript

             {
               $zip: { 
                  inputs: [ [ 1 ], [ 2, 3 ] ],
                  useLongestLength: true
               }
             }

        - ``[ [ 1, 2 ], [ null, 3 ] ]``

      * - .. code-block:: javascript

            {
               $zip: {
                  inputs: [ [ 1 ], [ 2, 3 ], [ 4 ] ],
                  useLongestLength: true,
                  defaults: [ -1, -1, -1 ]
               }
            }

        - ``[ [ 1, 2, 4 ], [ -1, 3, -1 ] ]``

New String Operators
~~~~~~~~~~~~~~~~~~~~

MongoDB 3.3 development series introduces the following new string
operators for the aggregation framework:

.. expression:: $indexOfBytes

   Searches a string for an occurence of a substring and returns the
   UTF-8 byte index (zero-based) of the first occurence. If the
   substring is not found, returns ``-1``.

   :expression:`$indexOfBytes` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $indexOfBytes: [ <string expression>, <substring expression>, <start>, <end> ] }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``<string expression>``

        - Can be any valid :ref:`expression
          <aggregation-expressions>` as long as it resolves to a
          string. For more information on expressions, see
          :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-indexOfBytes-string.rst

      * - ``<substring expression>``
        - Can be any valid :ref:`expression
          <aggregation-expressions>` as long as it resolves to a
          string. For more information on expressions, see
          :ref:`aggregation-expressions`.

      * - ``<start>`` 

        - *Optional* An integral number that specifies the starting index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number.

      * - ``<end>`` 

        - *Optional* An integral number that specifies the ending index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number. If you specify a ``<end>`` index
          value, you should also specify a ``<start>`` index value;
          otherwise, :expression:`$indexOfBytes` uses the ``<end>``
          value as the ``<start>`` index value instead of the ``<end>``
          value.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $indexOfBytes: [ "cafeteria", "e" ] }``
        - ``3``

      * - ``{ $indexOfBytes: [ "cafétéria", "é" ] }``
        - ``3``

      * - ``{ $indexOfBytes: [ "cafeteria", "t" ] }``
        - ``4``

      * - ``{ $indexOfBytes: [ "cafétéria", "t" ] }``
        - ``5``

      * - ``{ $indexOfBytes: [ "cafétéria", "e" ] }``
        - ``-1``

      * - ``{ $indexOfBytes: [ "foo.bar.fi", ".", 5 ] }``
        - ``7``

      * - ``{ $indexOfBytes: [ "vanilla", "nilla" ] }``
        - ``2``

   .. seealso:: :expression:`$indexOfCP`

.. expression:: $indexOfCP

   Searches a string for an occurence of a substring and returns the
   UTF-8 `code point <http://www.unicode.org/glossary/#code_point>`_
   index (zero-based) of the first occurence. If the substring is not
   found, returns ``-1``.

   :expression:`$indexOfCP` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $indexOfCP: [ <string expression>, <substring expression>, <start>, <end> ] }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``<string expression>``

        - Can be any valid :ref:`expression
          <aggregation-expressions>` as long as it resolves to a
          string. For more information on expressions, see
          :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-indexOfCP-string.rst

      * - ``<substring expression>``
        - Can be any valid :ref:`expression
          <aggregation-expressions>` as long as it resolves to a
          string. For more information on expressions, see
          :ref:`aggregation-expressions`.

      * - ``<start>`` 

        - *Optional* An integral number that specifies the starting index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number.

      * - ``<end>`` 

        - *Optional* An integral number that specifies the ending index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number. If you specify a ``<end>`` index
          value, you should also specify a ``<start>`` index value;
          otherwise, :expression:`$indexOfCP` uses the ``<end>``
          value as the ``<start>`` index value instead of the ``<end>``
          value.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $indexOfCP: [ "cafeteria", "e" ] }``
        - ``3``

      * - ``{ $indexOfCP: [ "cafétéria", "é" ] }``
        - ``3``

      * - ``{ $indexOfCP: [ "cafeteria", "t" ] }``
        - ``4``

      * - ``{ $indexOfCP: [ "cafétéria", "t" ] }``
        - ``4``

      * - ``{ $indexOfCP: [ "cafétéria", "e" ] }``
        - ``-1``

      * - ``{ $indexOfCP: [ "foo.bar.fi", ".", 5 ] }``
        - ``7``

      * - ``{ $indexOfCP: [ "vanilla", "nilla" ] }``
        - ``2``

   .. seealso:: :expression:`$indexOfBytes`

.. expression:: $split

   Splits a string by a specified delimiter into string components and
   returns an array of the string components.

   :expression:`$split` has the following :ref:`operator expression
   syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $split: [ <string expression to split>, <delimiter string expression>  }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``<string expression to split>``

        - Can be any valid :ref:`expression
          <aggregation-expressions>` as long as it resolves to an
          string. For more information on expressions, see
          :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-split-string.rst

      * - ``<delimiter string expression>``

        - Can be any valid :ref:`expression <aggregation-expressions>`
          as long as it resolves to an string. For more information on
          expressions, see :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-split-delimiter.rst

   .. list-table::
      :header-rows: 1
      :widths: 78 22

      * - Example
        - Results

      * - ``{ $split: [ "foo\nbar", "\n"] }``
        - ``[ "foo", "bar" ]``

      * - ``{ $split: [ "foo\nbar", "foo"] }``
        - ``[ "", "\nbar" ]``

      * - ``{ $split: [ "foo\nbar", "foo\nbar"] }``
        - ``[ "", "" ]``

      * - ``{ $split: [ null, "\n"] }``
        - ``null``

.. expression:: $strLenBytes

   Returns the number of UTF-8 bytes for a string.

   :expression:`$strLenBytes` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $strLenBytes: <string expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to a string. For
   more information on expressions, see :ref:`aggregation-expressions`.

   .. include:: /includes/extracts/agg-expression-null-operand-strLenBytes.rst

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $strLenBytes: "" }``
        - ``0``

      * - ``{ $strLenBytes: "cafe" }``
        - ``4``

      * - ``{ $strLenBytes: "café" }``
        - ``5``

   .. seealso:: :expression:`$strLenCP`

.. expression:: $strLenCP

   Returns the number of UTF-8 `code points
   <http://www.unicode.org/glossary/#code_point>`_ for a string.

   :expression:`$strLenCP` has the following :ref:`operator expression
   syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $strLenCP: <string expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` as long as it resolves to an string. For
   more information on expressions, see :ref:`aggregation-expressions`.

   .. include:: /includes/extracts/agg-expression-null-operand-strLenCP.rst

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $strLenCP: "" }``
        - ``0``

      * - ``{ $strLenCP: "cafe" }``
        - ``4``

      * - ``{ $strLenCP: "café" }``
        - ``4``

   .. seealso:: :expression:`$strLenBytes`

.. expression:: $substrBytes

   Returns the substring of a string. The substring starts with the
   character at the specified UTF-8 byte index (zero-based) in the
   string and continues for the number of bytes specified.

   :expression:`$substrBytes` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $substrBytes: <string expression>, <byte index>, <byte count> }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``<string expression>``

        - Specifies the string from which to extract the substring. Can
          be any valid :ref:`expression <aggregation-expressions>` as
          long as it resolves to a string. For more information on
          expressions, see :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-substrBytes.rst

      * - ``<byte index>``

        - Indicates the starting point of the substring. Can be any
          valid :ref:`expression <aggregation-expressions>` as long as
          it resolves to an integral number and does not result in a start
          index in the middle of a UTF-8 character.
   
          If a negative integral number, :expression:`$substrBytes` returns an
          empty string.

      * - ``<byte count>``

        - Can be any valid :ref:`expression <aggregation-expressions>`
          as long as it resolves to an integral number and does not result in
          an ending index in the middle of a UTF-8 character.

          If a negative integral number, the ending index is the end of the
          string.

          .. COMMENT to DOCS TEAM --
             there's inconsistencies in treatment of negative lengths.
             so, the above sentence will change
             https://jira.mongodb.org/browse/SERVER-25173

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $substrBytes: [ "abcde", 1, 2 ] }``
        - ``"bc"``

      * - ``{ $substrBytes: [ "cafétéria", 0, 5 ] }``
        - ``"café"``

      * - ``{ $substrBytes: [ "cafétéria", 5, 4 ] }``
        - ``"tér"``

      * - ``{ $substrBytes: [ "cafétéria", 6, -1 ] }``
        - ``"éria"``

   .. seealso:: :expression:`$substrCP`

.. expression:: $substrCP

   Returns the substring of a string. The substring starts with the
   character at the specified UTF-8 `code point (CP)
   <http://www.unicode.org/glossary/#code_point>`_ index (zero-based)
   in the string for the number of code points specified.

   :expression:`$substrCP` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $substrCP: <string expression>, <code point index>, <code point count> }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``<string expression>``

        - Specifies the string from which to extract the substring. Can
          be any valid :ref:`expression <aggregation-expressions>` as
          long as it resolves to a string. For more information on
          expressions, see :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-substrCP.rst

      * - ``<code point index>``

        - Indicates the starting point of the substring. Can be any
          valid :ref:`expression <aggregation-expressions>` as long as
          it resolves to a non-negative integral number.

      * - ``<code point count>``

        - Can be any valid :ref:`expression <aggregation-expressions>`
          as long as it resolves to a non-negative integral number.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $substrCP: [ "abcde", 1, 2 ] }``
        - ``"bc"``

      * - ``{ $substrCP: [ "cafétéria", 0, 5 ] }``
        - ``"cafét"``

      * - ``{ $substrCP: [ "cafétéria", 5, 4 ] }``
        - ``"éria"``

   .. seealso:: :expression:`$substrBytes`

New Control Flow Expression
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. expression:: $switch

   Evaluates, in sequential order, the ``case`` expressions of the
   specified branches to enter the first branch for which the ``case``
   expression evaluates to ``true``. The :expression:`$switch` operator
   executes the ``then`` expression for that branch and breaks out of
   the control flow.

   :expression:`$switch` has the following syntax:

   .. code-block:: javascript

      $switch: {
         branches: [
            { case: <expression>, then: <expression> },
            { case: <expression>, then: <expression> },
            ...
         ],
         default: <expression>
      }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``branches``

        - An array of control branch documents. Each branch is a
          document with the following fields:

          - ``case``
               The argument can be any valid :ref:`expression
               <aggregation-expressions>` that resolve to a boolean.
                         
          - ``then``
               The argument can be any valid :ref:`expression
               <aggregation-expressions>`.

          The ``branches`` array must contain at least one branch
          document.

      * - ``default``

        - Optional. The path to take if no branch ``case`` expression
          evaluates to ``true``.
          
          Although optional, if ``default`` is unspecified and no
          branch ``case`` evaluates to true, :expression:`$switch`
          returns an error.


   .. list-table::
      :header-rows: 1
      :widths: 80 20

      * - Example
        - Results

      * - .. code-block:: javascript

             {
                $switch: {
                   branches: [
                      { case: { $eq: [ 0, 5 ] }, then: "equals" },
                      { case: { $gt: [ 0, 5 ] }, then: "greater than" },
                      { case: { $lt: [ 0, 5 ] }, then: "less than" }
                   ]
                }
             }
             
        - ``"less than"``

      * - .. code-block:: javascript

             {
                $switch: {
                   branches: [ 
                      { case: { $eq: [ 0, 5 ] }, then: "equals" },
                      { case: { $gt: [ 0, 5 ] }, then: "greater than" }
                   ],
                   default: "Did not match"
                }
             }
             
        - ``"Did not match"``

New Date Aggregation Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. COMMENT to DOCSTeam -- will also need to update existing $dateToString  operator to support formatting of isodates "%G", "%V", and "%u" t

.. expression:: $isoDayOfWeek

   Returns the ISO 8601 weekday number, ranging from ``1`` (for Monday)
   to ``7`` (for Sunday).

   :expression:`$isoDayOfWeek` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $isoDayOfWeek: <date expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` that resolves to a date or timestamp.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $isoDayOfWeek: new Date("2016-01-01") }``
        - ``5``

   .. seealso:: :expression:`$dayOfWeek`

.. expression:: $isoWeek

   Returns the ISO 8601 week number, which can range from ``1`` to
   ``53``. Week numbers start at ``1`` with the week (Monday through
   Sunday) that contains the year's first Thursday.

   :expression:`$isoWeek` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $isoWeek: <date expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` that resolves to a date or timestamp.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $isoWeek: new Date("2015-01-01") }``
        - ``1``

      * - ``{ $isoWeek: new Date("2016-01-01") }``
        - ``53``

      * - ``{ $isoWeek: new Date("2016-01-04") }``
        - ``1``

   .. seealso:: :expression:`$week`

.. expression:: $isoWeekYear

   Returns the ISO 8601 year number, where the year starts with the
   Monday of week 1 (ISO 8601) and ends with the Sundays of the last
   week (ISO 8601)

   :expression:`$isoWeekYear` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $isoWeekYear: <date expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` that resolves to a date or timestamp.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $isoWeekYear: new Date("2015-01-01") }``
        - ``2015``

      * - ``{ $isoWeekYear: new Date("2016-01-01") }``
        - ``2015``

      * - ``{ $isoWeekYear: new Date("2016-01-04") }``
        - ``2016``

   .. seealso:: :expression:`$year`

Additional Aggregation Operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. expression:: $type

   Returns a string which specifies the :doc:`/reference/bson-types/`
   of the argument.

   For an array argument, the :expression:`$type` projection operator
   differs from the :query:`$type` query operator which descends into
   the array to match on the elements. Instead the :expression:`$type`
   projection operator returns the type of the argument, i.e.
   ``"array"``.
      
   :expression:`$type` has the following :ref:`operator expression
   syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $type: <expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>`.

   If the argument is a field that is missing in the input document,
   :expression:`$type` returns the string ``"missing"``.

   .. COMMENT to DocsTeam: in 3.4 manual, 
      mention in /reference/bson-types/ page and
      add disambiguation to :query:`$type` page.

   .. list-table::
      :header-rows: 1
      :widths: 35 15 50

      * - Example
        - Results
        - Note

      * - ``{ $type: "a" }``
        - ``"string"``
        - 

      * - ``{ $type: /a/ }``
        - ``"regex"``
        -

      * - ``{ $type: 1 }``
        - ``"double"``
        -

      * - ``{ $type: { x: 1 } }``
        - ``"object"``
        -

      * - ``{ $type: [ [ { x: 1 } ] ] }``
        - ``"array"``

        - Since the argument is a literal array ``[ { x: 1 } ]``, to
          avoid having MongoDB parse ``[ { x: 1 } ]`` as an
          :ref:`argument list <agg-quick-ref-operator-expressions>`
          with one argument ``{ x: 1 }``, the example uses the syntax
          form with the outer array brackets to designate an argument
          list. You can also wrap the array ``[ { x: 1 } ]`` in a
          :expression:`$literal` expression.

          See :ref:`operator expression syntax forms
          <agg-quick-ref-operator-expressions>` for more information.
