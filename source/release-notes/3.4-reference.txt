:orphan:

===============================
3.4 Release Candidate Reference
===============================

.. default-domain:: mongodb

.. include:: /includes/3.4.rst

See also :doc:`/release-notes/3.4`.

Aggregation Framework Enhancements
----------------------------------

New Stages
~~~~~~~~~~

MongoDB 3.4 release candidate introduces the following new
:ref:`aggregation pipeline stages <aggregation-pipeline>`.

.. pipeline:: $graphLookup

   Performs a recursive search on a collection. The stage matches the
   ``connectFromField`` of one document to the ``connectToField`` of
   other documents in the collection. Then, for any matching document,
   the :pipeline:`$graphLookup` uses the ``connectFromField`` of the
   matching document to match to the the ``connectToField`` of other
   documents, and continues until no new documents are encountered or
   until a specified depth. To each output document, the
   :pipeline:`$graphLookup` adds a new array field that contains the
   traversal results of the recursive search for that document.

   The :pipeline:`$graphLookup` stage has the following form:

   .. code-block:: javascript

      {
         $graphLookup: {
            from: <collection>,
            connectToField: <string>,
            startWith: <expression>,
            connectFromField: <string>,
            as: <string>,
            maxDepth: <number>,
            depthField: <string>,
            restrictSearchWithMatch: <document>
         }
      }

   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Field
        - Description

      * - ``from``

        - Collection on whose documents to perfrom
          :pipeline:`$graphLookup`, recursively matching on the
          ``connectFromField`` to the ``connectToField``.

          The ``from`` collection cannot not be sharded.

      * - ``connectFromField``

        - Field name whose value :pipeline:`$graphLookup` uses to
          recursively match against the ``connectToField`` of other
          documents in the collection.

      * - ``startWith``

        - Expression that specifies the value of the
          ``connectFromField`` with which to start the recursive
          search.

      * - ``connectToField``

        - Field name in other document against which to match the
          ``connectToField``.

      * - ``as``

        - Field name of the array field added to each output document
          that contains the documents traversed in the
          :pipeline:`$graphLookup` stage for the document.

      * - ``maxDepth``
        - Non-negative integral number that specifies the maximum
          recursive depth.

      * - ``depthField`` 

        - *Optional.* Name of the field to add to each traversed
          document in the search path. The field holds the recursion depth for
          the document. Depth value starts at zero; i.e. the first
          lookup corresponds to zero depth.

      * - ``restrictSearchWithMatch``

        - A document that specifies additional condition for the
          recursive search. The syntax is identical to the :ref:`query
          filter <read-operations-query-argument>` syntax.

   .. COMMENT to DocsTeam: Be sure to include an example using the 'restrictSearchByMatch'
   
   Consider a collection ``employees`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "name" : "Dev" }
      { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
      { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }
      { "_id" : 4, "name" : "Andrew", "reportsTo" : "Eliot" }
      { "_id" : 5, "name" : "Asya", "reportsTo" : "Ron" }
      { "_id" : 6, "name" : "Dan", "reportsTo" : "Andrew" }

   The following :pipeline:`$graphLookup` operation traverses the
   documents in the collection to recursively match on the
   ``reportsTo`` and ``name`` to return the reporting hierarchy for
   each person:

   .. code-block:: javascript

      db.employees.aggregate( [
         {
            $graphLookup: {
               from: "employees",
               startWith: "$reportsTo",
               connectFromField: "reportsTo",
               connectToField: "name",
               as: "reportingHierarchy"
            }
         }
      ] )
   
   The operation returns the following documents:
   
   .. code-block:: javascript
   
      { "_id" : 1, "name" : "Dev", "reportingHierarchy" : [ ] }
      {
      
         "_id" : 2,
         "name" : "Eliot",
         "reportsTo" : "Dev",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" }
         ]
      }
      {
         "_id" : 3,
         "name" : "Ron",
         "reportsTo" : "Eliot",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
         ]
      }
      {
         "_id" : 4,
         "name" : "Andrew",
         "reportsTo" : "Eliot",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
         ]
      }
      {
         "_id" : 5,
         "name" : "Asya",
         "reportsTo" : "Ron",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" },
            { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }
         ]
      }
      {
         "_id" : 6,
         "name" : "Dan",
         "reportsTo" : "Andrew",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" },
            { "_id" : 4, "name" : "Andrew", "reportsTo" : "Eliot" }
         ]
      }

   The following table provides a traversal path for operation for the
   document ``{ "_id" : 5, "name" : "Asya", "reportsTo" : "Ron" }``:

   .. list-table::
      :stub-columns: 1

      * - Start value

        - The ``reportsTo`` value of the document:

          .. code-block:: javascript

             { ... "reportsTo" : "Ron" }

      * - Depth 0

        - .. code-block:: javascript

             { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }

      * - Depth 1

        - .. code-block:: javascript

             { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }

      * - Depth 2
         
        - .. code-block:: javascript

             { "_id" : 1, "name" : "Dev" }
   
   
   Similar to :pipeline:`$lookup`, :pipeline:`$graphLookup` can access
   another collection in the same database. For example, a database
   contains the following collections:

   - A collection ``airports`` that contains the following documents:

     .. code-block:: javascript

        { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ] }
        { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ] }
        { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ] }
        { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ] }
        { "_id" : 4, "airport" : "LHR", "connects" : [ "PWM" ] }

   - A collection ``travelers`` that contains the following documents:

     .. code-block:: javascript

        { "_id" : 1, "name" : "Dev", "nearestAirport" : "JFK" }
        { "_id" : 2, "name" : "Eliot", "nearestAirport" : "JFK" }
        { "_id" : 3, "name" : "Jeff", "nearestAirport" : "BOS" }

   For each document in the ``travelers`` collection, the following
   operation looks up a the ``nearestAirport`` value in the
   ``airports`` collection, and recursively matches the ``connects``
   field to the ``airport`` fields in documents in the ``airports``
   collection. The operation specifies a maximum number of recursion to
   ``2``.

   .. code-block:: javascript

      db.travelers.aggregate( [
         {
            $graphLookup: {
               from: "airports",
               startWith: "$nearestAirport",
               connectFromField: "connects",
               connectToField: "airport",
               maxDepth: 2,
               depthField: "numConnections",
               as: "destinations"
            }
         }
      ] )

   The operation returns the following results:
   
   .. code-block:: javascript
   
      {
         "_id" : 1,
         "name" : "Dev",
         "nearestAirport" : "JFK",
         "destinations" : [
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(2) },
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(1) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(0) }
         ] 
      }
      {
         "_id" : 2,
         "name" : "Eliot",
         "nearestAirport" : "JFK",
         "destinations" : [ 
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(2) },
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(1) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(0) } ]
      }
      {
         "_id" : 3,
         "name" : "Jeff",
         "nearestAirport" : "BOS",
         "destinations" : [
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(2) },
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(1) },
            { "_id" : 4, "airport" : "LHR", "connects" : [ "PWM" ], "numConnections" : NumberLong(2) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(0) }
         ]
      }
   
   The following table provides a traversal path for the recursive
   search, up to depth 2, where the starting ``airport`` is ``JFK``:

   .. list-table::
      :stub-columns: 1

      * - Start value

        - The ``nearestAirport`` value from the ``travelers`` collection:

          .. code-block:: javascript

             { ... "nearestAirport" : "JFK" }

      * - Depth 0

        - .. code-block:: javascript

             { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ] }

      * - Depth 1

        - .. code-block:: javascript

             { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ] }
             { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ] }
            
      * - Depth 2
         
        - .. code-block:: javascript

             { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ] }

   .. seealso:: :ref:`agg-memory-restrictions`


.. pipeline:: $addFields

   Adds new fields to documents. The stage outputs documents that
   contains all existing fields from the input documents and newly
   added fields.

   The :pipeline:`$addFields` stage is equivalent to a
   :pipeline:`$project` stage that explicitly specifies all existing
   fields in the input documents and the new fields.

   The :pipeline:`$addFields` stage has the following form:

   .. code-block:: javascript

      { $addFields: { <newField>: <expression>, ... } }

   Specify the name of the field to add and set its value to an
   :ref:`aggregation expression <aggregation-expressions>`. For more
   information on expressions, see :ref:`aggregation-expressions`.

   If the name of the new field corresponds to an existing field name,
   :pipeline:`$addFields` overwrites the existing value of that field
   with the specified expression value.

   .. COMMENT to DocsTeam -- need to add a Behavior section to describe
      the behavior when used with arrays and embedded document. Add
      examples as well. Refer to existing agg pages for the level of
      details needed on these pages.s

   Consider a collection ``scores`` with the following documents:

   .. code-block:: javascript

      {
        _id: 1, 
        student: "abc",
        homework: [ 10, 5, 10 ],
        quiz: [ 10, 8 ],
        extraCredit: 0
      }
      {
        _id: 2,
        student: "xyz",
        homework: [ 5, 6, 5 ],
        quiz: [ 8, 8 ],
        extraCredit: 8
      }

   The following operation uses two :pipeline:`$addFields` stages to
   include three new fields in the output documents:

   .. code-block:: javascript

      db.scores.aggregate( [
         {
           $addFields: {
             totalHomework: { $sum: "$homework" } ,
             totalQuiz: { $sum: "$quiz" }
           }
         },
         {
           $addFields: { totalScore: { $add: [ "$totalHomework", "$totalQuiz", "$extraCredit" ] } }
         }
      ] )

   The operation returns the following documents:

   .. code-block:: javascript

      { 
        "_id" : 1,
        "student" : "abc",
        "homework" : [ 10, 5, 10 ],
        "quiz" : [ 10, 8 ],
        "extraCredit" : 0, 
        "totalHomework" : 25,
        "totalQuiz" : 18,
        "totalScore" : 43
      }
      { 
        "_id" : 2,
        "student" : "xyz",
        "homework" : [ 5, 6, 5 ],
        "quiz" : [ 8, 8 ],
        "extraCredit" : 8,
        "totalHomework" : 16,
        "totalQuiz" : 16,
        "totalScore" : 40
      }

.. pipeline:: $replaceRoot

   Replaces a document with the specified document. The operation
   replaces all existing fields in the input document, including the
   ``_id`` field. You can specify a document embedded in the input
   document to promote the embedded document to the top level.

   The :pipeline:`$replaceRoot` stage has the following form:

   .. code-block:: javascript

      { $replaceRoot: { newRoot: <replacementDocument> } }

   The replacement document can be any valid expression
   :ref:`expression <aggregation-expressions>` that resolves to a
   document.

   Consider a collection ``items`` with the following document:

   .. code-block:: javascript

      { _id: 1, item: "ABC1", details: { sku: "CH123", model: "XYZ", quantity: 25 } }
      { _id: 2, item: "IJK1", details: { sku: "MM012", model: "MNH", quantity: 25, style: { color: "red", size: "M" } } }

   The following operation uses the :pipeline:`$replaceRoot` stage to
   promote the ``details`` document to the top level, discarding the
   current top level fields.

   .. code-block:: javascript

      db.items.aggregate( [
         {
           $replaceRoot: { newRoot: "$details" }
         }
      ] )

   The operation returns the following documents:

   .. code-block:: javascript

      { "sku" : "CH123", "model" : "XYZ", "quantity" : 25 }
      { "sku" : "MM012", "model" : "MNH", "quantity" : 25, "style" : { "color" : "red", "size" : "M" } }

.. pipeline:: $bucket

   Categorizes or groups incoming documents into buckets that represent
   a range of values for a specified expression. Each output document
   contains an ``_id`` field, whose value is the inclusive lower bound
   of the bucket range, and by default, a ``count`` field that contains
   the number of documents that fall into the bucket.
   
   :pipeline:`$bucket` only outputs documents for non-empty buckets
   (i.e. buckets with ``count`` greater than or equal to one).

   .. code-block:: javascript

      { 
        $bucket: {
            groupBy: <expression>,
            boundaries: [ <lowerbound1>, <lowerbound2>, ... ],
            default: <literal>,
            output: {
               <output1>: { <$accumulator expression> },
               ...
            }
         }
      }
   
   .. list-table::
      :header-rows: 1
      :widths: 20 80

      * - Field
        - Description

      * - ``groupBy``

        - :ref:`Expression <aggregation-expressions>` to group by. To
          specify a :ref:`field path <agg-quick-ref-field-paths>`,
          prefix the field name with a dollar sign ``$`` and enclose in
          quotes.
          
          Unless :pipeline:`$bucket` includes a ``default``
          specification, each input document must resolve the
          ``groupBy`` field path or expression to a value that falls
          within one of the ranges specified by the ``boundaries``.

      * - ``boundaries``

        - An array that specifies the boundaries for the bucket, or the
          range of values, for the ``groupBy`` expression. Each
          adjacent pair of values acts as the inclusive lower boundary
          and the exclusive upper boundary for the bucket.

          For example, an array of ``[ 0, 5, 10 ]`` creates two buckets:

          - [0, 5) with inclusive lowerbound ``0`` and exclusive upper bound ``5``.

          - [5, 10) with inclusive lowerbound ``5`` and exclusive upper bound ``10``.

          The boundaries must be of the same type and in ascending
          order.

          Unless :pipeline:`$bucket` includes a ``default``
          specification, each input document must resolve the
          ``groupBy`` field path or expression to a value that falls
          within one of the ranges specified by the ``boundaries``.

          You must specify at least two boundaries.
          
      * - ``default``
      
        - Optional. A literal that specifies the default bucket for any document
          whose ``groupBy`` expression does not fall into one of the
          buckets as specified by the ``boundaries``.
          
          The ``default`` value cannot overlap with a bucket; i.e. must
          be less than the lowest boundary or greater than the highest
          boundary.
          
          If ``default`` is unspecified, each input document must
          resolve the ``groupBy`` field path or expression to a value
          that falls within one of the ranges specified by the
          ``boundaries``.
   
      * - ``output``
      
        - Optional. A document that specifies the fields to include in the output
          documents in addition to the ``_id`` field. To specify the
          field to include, you must use :ref:`accumulator expressions
          <agg-quick-reference-accumulators>`.

          .. code-block:: javascript
           
             <outputfield1>: { <accumulator>: <expression1> },
             ...
           
          By default, the output documents include the ``count`` field
          that contains the number of documents that fall into the
          bucket. The default is equivalent to explicitly specifying:
           
          .. code-block:: javascript
           
             output: { count: { $sum: 1 } }
           
   Consider a collection ``exhibits`` with the following documents:

   .. code-block:: javascript

      { _id: 1, title: "The Pillars of Society", "artist" : "Grosz", year: 1926,
        tags: [ "painting", "satire", "Expressionism", "caricature" ] }
      { _id: 2, title: "Melancholy III", "artist" : "Munch", year: 1902,
        tags: [ "woodcut", "Expressionism" ] },
      { _id: 3, title: "Dancer", "artist" : "Miro", year: 1925,
        tags: [ "oil", "Surrealism", "painting" ] }
      { _id: 4, title: "The Great Wave off Kanagawa", artist: "Hokusai", 
         tags: [ "woodblock", "ukiyo-e" ] }
 
   The following operation groups the input documents by the ``year``
   field and categorizes the documents by the ``year`` value into 4
   buckets (three user-specified buckets and one default bucket).
  
   .. code-block:: javascript
               
      db.exhibits.aggregate( [ 
         { $bucket: { 
               groupBy: "$year",
               boundaries: [ 1900, 1920, 1950 ],
               default: "Unknown",
               output: { years: { $push: "$year" }, count: { $sum: 1 } } } }
      ] )

   The operation returns the following documents that correspond to
   non-empty buckets:

   .. code-block:: javascript
   
      { "_id" : 1900, "years" : [ 1902 ], "count" : 1 }
      { "_id" : 1920, "years" : [ 1926, 1925 ], "count" : 2 }
      { "_id" : "Unknown", "years" : [ ], "count" : 1 }

.. pipeline:: $bucketAuto

   Categorizes or groups incoming documents into buckets that represent
   a range of values for a specified expression.
   :pipeline:`$bucketAuto` automatically determines the bucket ranges
   in its attempt to distribute the documents evenly into a specified
   number of buckets. Depending on the input documents, the number of
   buckets may be less than the specified number of buckets.
   
   Each output document contains an ``_id`` field, whose value is a
   document that specifies the inclusive lower bound and the exclusive
   upper bound for the bucket, and by default, a ``count`` field that
   contains the number of documents that fall into the bucket.

   The :pipeline:`$bucketAuto` stage has the following form:

   .. code-block:: javascript

      { 
        $bucketAuto: {
            groupBy: <expression>,
            buckets: <number>,
            output: {
               <output1>: { <$accumulator expression> },
               ...
            }
            granularity: <string>
        }
      }
   
   .. list-table::
      :header-rows: 1
      :widths: 20 80

      * - Field
        - Description

      * - ``groupBy``

        - :ref:`Expression <aggregation-expressions>` to group by. To
          specify a :ref:`field path <agg-quick-ref-field-paths>`,
          prefix the field name with a dollar sign ``$`` and enclose in
          quotes.

      * - ``buckets``

        - A positive 32-bit integral number; i.e. a number whose value
          can be represented as a 32-bit integer.
                       
      * - ``output``
      
        - Optional. A document that specifies the fields to include in
          the output documents in addition to the ``_id`` field. To
          specify the field to include, you must use :ref:`accumulator
          expressions <agg-quick-reference-accumulators>`.

          .. code-block:: javascript
           
             <outputfield1>: { <accumulator>: <expression1> },
             ...
           
          By default, the output documents include the ``count`` field
          that contains the number of documents that fall into the
          bucket. The default is equivalent to explicitly specifying:
           
          .. code-block:: javascript
           
             output: { count: { $sum: 1 } }

      * - ``granularity``

        - Optional. String that specifies the `preferred number series
          <https://en.wikipedia.org/wiki/Preferred_number>`_ to use to
          ensure that the calculated boundary edges end on preferred
          round numbers.

          Available only if the all ``groupBy`` values are numeric and
          none of them are NaN.

          The suppported values of ``granularity`` are:

          .. list-table::
             :class: index-table

             * - 
                 - ``"R5"``

                 - ``"R10"``

                 - ``"R20"``

                 - ``"R40"``

                 - ``"R80"``

                 - ``"1-2-5"``

               - - ``"E6"``

                 - ``"E12"``

                 - ``"E24"``

                 - ``"E48"``

                 - ``"E96"``

                 - ``"E192"``

                 - ``"POWERSOF2"``

   Consider a collection ``exhibits`` with the following documents:

   .. code-block:: javascript

      { _id: 1, title: "The Pillars of Society", "artist" : "Grosz", year: 1926,
        tags: [ "painting", "satire", "Expressionism", "caricature" ] }
      { _id: 2, title: "Melancholy III", "artist" : "Munch", year: 1902,
        tags: [ "woodcut", "Expressionism" ] }
      { _id: 3, title: "Dancer", "artist" : "Miro", year: 1925,
        tags: [ "oil", "Surrealism", "painting" ] }
      { _id: 4, title: "The Great Wave off Kanagawa", artist: "Hokusai", 
         tags: [ "woodblock", "ukiyo-e" ] }

   The following operation groups the input documents by the ``year``
   field and autobuckets the year values into at most ``4`` buckets:
    
   .. code-block:: javascript
               
      db.exhibits.aggregate( [ 
         { 
           $bucketAuto: { 
               groupBy: "$year",
               buckets: 4
           }
         }
      ] )

   The operation returns the following documents:
   
   .. code-block:: javascript
   
      { "_id" : { "min" : null, "max" : 1902 }, "count" : 1 }
      { "_id" : { "min" : 1902, "max" : 1925 }, "count" : 1 }
      { "_id" : { "min" : 1925, "max" : 1926 }, "count" : 1 }
      { "_id" : { "min" : 1926, "max" : 1926 }, "count" : 1 }

   The following operation groups the input documents by the ``year``
   field and autobuckets the year values into at most ``4`` buckets:

   .. code-block:: javascript
               
      db.exhibits.aggregate( [ 
         { 
           $bucketAuto: { 
               groupBy: "$year",
               buckets: 4,
               output: { 
                  years: { $push: "$year" },
                  count: { $sum: 1 }  
               } 
           }
         }
      ] )
   
   The operation returns the following documents:

   .. code-block:: javascript
   
      { "_id" : { "min" : null, "max" : 1902 }, "years" : [ ], "count" : 1 }
      { "_id" : { "min" : 1902, "max" : 1925 }, "years" : [ 1902 ], "count" : 1 }
      { "_id" : { "min" : 1925, "max" : 1926 }, "years" : [ 1925 ], "count" : 1 }
      { "_id" : { "min" : 1926, "max" : 1926 }, "years" : [ 1926 ], "count" : 1 }

.. pipeline:: $facet

   Provides the ability to process multiple :ref:`pipelines
   <aggregation-pipeline>` on the input documents and outputs a
   document that contains the results of these pipelines. By specifying
   facet-related stages (:pipeline:`$bucket`, :pipeline:`$bucketAuto`,
   and :pipeline:`$sortByCount`) in these pipelines, :pipeline:`$facet`
   allows for multi-faceted search.

   The :pipeline:`$facet` stage has the following form:

   .. code-block:: javascript

      { $facet:
         {
            <outputField1>: [ <stage1>, <stage2>, ... ],
            ...

         }
      }

   For the ``<stage>`` values, you cannot specify any one of the
   following stages:

   - :pipeline:`$facet`
   - :pipeline:`$out`
   - :pipeline:`$geoNear`
   - :pipeline:`$indexStats`
   - :pipeline:`$collStats`

   Specify the output field name for each specified pipeline.

   Consider a collection ``exhibits`` with the following documents:

   .. code-block:: javascript

      { _id: 1, title: "The Pillars of Society", "artist" : "Grosz", year: 1926,
        tags: [ "painting", "satire", "Expressionism", "caricature" ] }
      { _id: 2, title: "Melancholy III", "artist" : "Munch", year: 1902,
        tags: [ "woodcut", "Expressionism" ] },
      { _id: 3, title: "Dancer", "artist" : "Miro", year: 1925,
        tags: [ "oil", "Surrealism", "painting" ] }
      { _id: 4, title: "The Great Wave off Kanagawa", artist: "Hokusai", 
         tags: [ "woodblock", "ukiyo-e" ] }

   .. code-block:: javascript
  
      db.exhibits.aggregate( [
         {
            $facet: {
               
               "categorizedByTags": [  { $unwind: "$tags" },  { $sortByCount: "$tags" } ], 
               "categorizedByYears": [ 
                  { $match: { year: {$exists: 1 } } },
                  { $bucket: { groupBy: "$year", boundaries: [ 1900, 1920, 1950 ] } }
               ],
               "categorizedByYears(Auto)": [ { $bucketAuto: { groupBy: "$year", buckets: 4 } } ]
                     
            }
         }
      ])   

   The operation outputs the following documents:

   .. code-block:: javascript
   
      {
         "categorizedByYears(Auto)" : [
            { "_id" : { "min" : null, "max" : 1902 }, "count" : 1 },
            { "_id" : { "min" : 1902, "max" : 1925 }, "count" : 1 },
            { "_id" : { "min" : 1925, "max" : 1926 }, "count" : 1 },
            { "_id" : { "min" : 1926, "max" : 1926 }, "count" : 1 }
         ],
         "categorizedByYears" : [
            { "_id" : 1900, "count" : 1 },
            { "_id" : 1920, "count" : 2 }
         ],
         "categorizedByTags" : [
            { "_id" : "Expressionism", "count" : 2 },
            { "_id" : "painting", "count" : 2 },
            { "_id" : "woodblock", "count" : 1 },
            { "_id" : "Surrealism", "count" : 1 },
            { "_id" : "oil", "count" : 1 },
            { "_id" : "woodcut", "count" : 1 },
            { "_id" : "ukiyo-e", "count" : 1 },
            { "_id" : "satire", "count" : 1 },
            { "_id" : "caricature", "count" : 1 }
         ]
      }


New Array Operators
~~~~~~~~~~~~~~~~~~~~

MongoDB 3.4 release candidate introduces the following new array
operators for the aggregation framework:

.. expression:: $in

   Returns a boolean that indicates if a specified value is in an array.

   :expression:`$in` has the following :ref:`operator expression syntax
   <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $in: [ <expression>, <array expression> ] }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.

   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Operand
        - Description

      * - ``<expression>`` 

        - Any valid expression :ref:`expression
          <aggregation-expressions>`.

      * - ``<array expression>`` 

        - Any valid :ref:`expression <aggregation-expressions>` that
          resolves to an array.

   Unlike the :query:`$in` query operator which can support
   :ref:`regular expressions <query-in-regex>` to match values, the
   aggregation :expression:`$in` operator does not support matching by
   :ref:`regular expressions <query-in-regex>`.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $in: [ 2, [ 1, 2, 3 ] ] }``
        - ``true``

      * - ``{ $in: [ "abc", [ "xyz", "abc" ] ] }``
        - ``true``

      * - ``{ $in: [ "xy", [ "xyz", "abc" ] ] }``
        - ``false``

      * - ``{ $in: [ ["a"], [ "a" ] ] }``
        - ``false``

      * - ``{ $in: [ ["a"], [ ["a"] ] ] }``
        - ``true``

      * - ``{ $in: [ /^a/, [ "a" ] ] }``
        - ``false``

      * - ``{ $in: [ /^a/, [ "a" ] ] }``
        - ``false``

      * - ``{ $in: [ /^a/, [ /^a/ ] ] }``
        - ``true``

.. expression:: $indexOfArray

   Searches an array for an occurence of a specified value and returns
   the array index (zero-based) of the first occurence. If the
   substring is not found, returns ``-1``.

   :expression:`$indexOfArray` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $indexOfArray: [ <array expression>, <search expression>, <start>, <end> ] }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
      
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work

   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``<array expression>``

        - Can be any valid :ref:`expression
          <aggregation-expressions>` as long as it resolves to an
          array. For more information on expressions, see
          :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-indexOfArray-string.rst

      * - ``<search expression>``
        - Can be any valid :ref:`expression
          <aggregation-expressions>`. For more information on expressions, see
          :ref:`aggregation-expressions`.

      * - ``<start>`` 

        - *Optional* An integral number that specifies the starting index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number.

      * - ``<end>`` 

        - *Optional* An integral number that specifies the ending index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number. If you specify a ``<end>`` index
          value, you should also specify a ``<start>`` index value;
          otherwise, :expression:`$indexOfArray` uses the ``<end>``
          value as the ``<start>`` index value instead of the ``<end>``
          value.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $indexOfArray: [ [ "a", "abc" ] , "a" ] }``
        - ``0``

      * - ``{ $indexOfArray: [ [ "a", "abc", "de", ["de"] ], ["de"] ] }``
        - ``3``

      * - ``{ $indexOfArray: [ [ 1, 2 ], 5 ] }``
        - ``-1``

      * - ``{ $indexOfArray: [ [ 10, 9, 9, 8, 9 ], 9, 3 ] }``
        - ``4``

      * - ``{ $indexOfArray: [ [ "a", "abc", "b" ] , "b", 0, 1 ] }``

        - ``-1``

   .. seealso:: :expression:`$in`


.. expression:: $zip

   Returns an output array where each element is itself an array,
   consisting of elements in the corresponding array index position
   from the input arrays. That is, the first element in the output
   array is an array consisting of the first element from each of the
   input arrays.

   The input arrays do not need to be of the same length. By default,
   the length of the shortest input array determines the length of the
   output array, but you can also have the longest input array
   determine the output array.

   :expression:`$zip` has the following syntax:

   .. code-block:: javascript

      {
          $zip: {
              inputs: [ <array expression1>,  ... ],
              useLongestLength: <boolean>,
              defaults:  <array expression> 
          }
      }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.

   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``inputs``

        - An array of :ref:`expressions <aggregation-expressions>` that
          resolve to arrays. The elements of these arrays combine to
          form the array element of the output array.

          .. include:: /includes/extracts/agg-expression-null-operand-zip.rst

      * - ``useLongestLength``

        - A boolean which specifies whether the length of the longest
          array determines the number of elements in the output array.

          Default value is ``false``; i.e. the shortest array length
          determines the number of elements in the output array.

      * - ``defaults``

        - An array of default element values to use for *each* input
          array if the array index position exceeds the array length.
          Use in conjunction with ``useLongestLength: true``. 
          
          If ``useLongestLength: true`` and the ``defaults`` array is
          unspecified, :expression:`$zip` uses ``null`` as the default
          values.
          
          If specifying ``defaults``, you must specify a default for
          *each* input array.

          Invalid if ``useLongestLength`` is ``false``.

   .. list-table::
      :header-rows: 1
      :widths: 60 35

      * - Example
        - Results

      * - ``{ $zip: { inputs: [ [ 'a' ], [ 'b' ], [ 'c' ] ] }``
        - ``[ [ "a", "b", "c" ] ]``

      * - ``{ $zip: { inputs: [ [ 'a' ], [ 'b', 'c' ] ] } }``
        - ``[ [ "a", "b" ] ]``

      * - .. code-block:: javascript

             {
               $zip: { 
                  inputs: [ [ 1 ], [ 2, 3 ] ],
                  useLongestLength: true
               }
             }

        - ``[ [ 1, 2 ], [ null, 3 ] ]``

      * - .. code-block:: javascript

            {
               $zip: {
                  inputs: [ [ 1 ], [ 2, 3 ], [ 4 ] ],
                  useLongestLength: true,
                  defaults: [ -1, -1, -1 ]
               }
            }

        - ``[ [ 1, 2, 4 ], [ -1, 3, -1 ] ]``

New String Operators
~~~~~~~~~~~~~~~~~~~~

MongoDB 3.4 release candidate introduces the following new string
operators for the aggregation framework:

.. expression:: $indexOfCP

   Searches a string for an occurence of a substring and returns the
   UTF-8 `code point <http://www.unicode.org/glossary/#code_point>`_
   index (zero-based) of the first occurence. If the substring is not
   found, returns ``-1``.

   :expression:`$indexOfCP` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $indexOfCP: [ <string expression>, <substring expression>, <start>, <end> ] }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``<string expression>``

        - Can be any valid :ref:`expression
          <aggregation-expressions>` as long as it resolves to a
          string. For more information on expressions, see
          :ref:`aggregation-expressions`.

          .. include:: /includes/extracts/agg-expression-null-operand-indexOfCP-string.rst

      * - ``<substring expression>``
        - Can be any valid :ref:`expression
          <aggregation-expressions>` as long as it resolves to a
          string. For more information on expressions, see
          :ref:`aggregation-expressions`.

      * - ``<start>`` 

        - *Optional* An integral number that specifies the starting index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number.

      * - ``<end>`` 

        - *Optional* An integral number that specifies the ending index
          position for the search. Can be any valid expression
          :ref:`expression <aggregation-expressions>` that resolves to
          a non-negative integral number. If you specify a ``<end>`` index
          value, you should also specify a ``<start>`` index value;
          otherwise, :expression:`$indexOfCP` uses the ``<end>``
          value as the ``<start>`` index value instead of the ``<end>``
          value.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $indexOfCP: [ "cafeteria", "e" ] }``
        - ``3``

      * - ``{ $indexOfCP: [ "cafétéria", "é" ] }``
        - ``3``

      * - ``{ $indexOfCP: [ "cafeteria", "t" ] }``
        - ``4``

      * - ``{ $indexOfCP: [ "cafétéria", "t" ] }``
        - ``4``

      * - ``{ $indexOfCP: [ "cafétéria", "e" ] }``
        - ``-1``

      * - ``{ $indexOfCP: [ "foo.bar.fi", ".", 5 ] }``
        - ``7``

      * - ``{ $indexOfCP: [ "vanilla", "nilla" ] }``
        - ``2``

   .. seealso:: :expression:`$indexOfBytes`


New Control Flow Expression
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. expression:: $switch

   Evaluates, in sequential order, the ``case`` expressions of the
   specified branches to enter the first branch for which the ``case``
   expression evaluates to ``true``. The :expression:`$switch` operator
   executes the ``then`` expression for that branch and breaks out of
   the control flow.

   :expression:`$switch` has the following syntax:

   .. code-block:: javascript

      $switch: {
         branches: [
            { case: <expression>, then: <expression> },
            { case: <expression>, then: <expression> },
            ...
         ],
         default: <expression>
      }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``branches``

        - An array of control branch documents. Each branch is a
          document with the following fields:

          - ``case``
               The argument can be any valid :ref:`expression
               <aggregation-expressions>` that resolve to a boolean.
                         
          - ``then``
               The argument can be any valid :ref:`expression
               <aggregation-expressions>`.

          The ``branches`` array must contain at least one branch
          document.

      * - ``default``

        - Optional. The path to take if no branch ``case`` expression
          evaluates to ``true``.
          
          Although optional, if ``default`` is unspecified and no
          branch ``case`` evaluates to true, :expression:`$switch`
          returns an error.


   .. list-table::
      :header-rows: 1
      :widths: 80 20

      * - Example
        - Results

      * - .. code-block:: javascript

             {
                $switch: {
                   branches: [
                      { case: { $eq: [ 0, 5 ] }, then: "equals" },
                      { case: { $gt: [ 0, 5 ] }, then: "greater than" },
                      { case: { $lt: [ 0, 5 ] }, then: "less than" }
                   ]
                }
             }
             
        - ``"less than"``

      * - .. code-block:: javascript

             {
                $switch: {
                   branches: [ 
                      { case: { $eq: [ 0, 5 ] }, then: "equals" },
                      { case: { $gt: [ 0, 5 ] }, then: "greater than" }
                   ],
                   default: "Did not match"
                }
             }
             
        - ``"Did not match"``

New Date Aggregation Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. COMMENT to DOCSTeam -- will also need to update existing $dateToString  operator to support formatting of isodates "%G", "%V", and "%u" t

.. expression:: $isoDayOfWeek

   Returns the ISO 8601 weekday number, ranging from ``1`` (for Monday)
   to ``7`` (for Sunday).

   :expression:`$isoDayOfWeek` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $isoDayOfWeek: <date expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` that resolves to a date or timestamp.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $isoDayOfWeek: new Date("2016-01-01") }``
        - ``5``

   .. seealso:: :expression:`$dayOfWeek`

.. expression:: $isoWeek

   Returns the ISO 8601 week number, which can range from ``1`` to
   ``53``. Week numbers start at ``1`` with the week (Monday through
   Sunday) that contains the year's first Thursday.

   :expression:`$isoWeek` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $isoWeek: <date expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` that resolves to a date or timestamp.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $isoWeek: new Date("2015-01-01") }``
        - ``1``

      * - ``{ $isoWeek: new Date("2016-01-01") }``
        - ``53``

      * - ``{ $isoWeek: new Date("2016-01-04") }``
        - ``1``

   .. seealso:: :expression:`$week`

.. expression:: $isoWeekYear

   Returns the ISO 8601 year number, where the year starts with the
   Monday of week 1 (ISO 8601) and ends with the Sundays of the last
   week (ISO 8601)

   :expression:`$isoWeekYear` has the following :ref:`operator
   expression syntax <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $isoWeekYear: <date expression> }

   The argument can be any valid :ref:`expression
   <aggregation-expressions>` that resolves to a date or timestamp.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $isoWeekYear: new Date("2015-01-01") }``
        - ``2015``

      * - ``{ $isoWeekYear: new Date("2016-01-01") }``
        - ``2015``

      * - ``{ $isoWeekYear: new Date("2016-01-04") }``
        - ``2016``

   .. seealso:: :expression:`$year`
