:orphan:

===============================
3.4 Release Candidate Reference
===============================

.. default-domain:: mongodb

.. include:: /includes/3.4.rst

See also :doc:`/release-notes/3.4`.

Aggregation Framework Enhancements
----------------------------------

New Stages
~~~~~~~~~~

MongoDB 3.4 release candidate introduces the following new
:ref:`aggregation pipeline stages <aggregation-pipeline>`.

.. pipeline:: $graphLookup

   Performs a recursive search on a collection. The stage matches the
   ``connectFromField`` of one document to the ``connectToField`` of
   other documents in the collection. Then, for any matching document,
   the :pipeline:`$graphLookup` uses the ``connectFromField`` of the
   matching document to match to the the ``connectToField`` of other
   documents, and continues until no new documents are encountered or
   until a specified depth. To each output document, the
   :pipeline:`$graphLookup` adds a new array field that contains the
   traversal results of the recursive search for that document.

   The :pipeline:`$graphLookup` stage has the following form:

   .. code-block:: javascript

      {
         $graphLookup: {
            from: <collection>,
            connectToField: <string>,
            startWith: <expression>,
            connectFromField: <string>,
            as: <string>,
            maxDepth: <number>,
            depthField: <string>,
            restrictSearchWithMatch: <document>
         }
      }

   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Field
        - Description

      * - ``from``

        - Collection on whose documents to perfrom
          :pipeline:`$graphLookup`, recursively matching on the
          ``connectFromField`` to the ``connectToField``.

          The ``from`` collection cannot be sharded.

      * - ``connectFromField``

        - Field name whose value :pipeline:`$graphLookup` uses to
          recursively match against the ``connectToField`` of other
          documents in the collection.

      * - ``startWith``

        - Expression that specifies the value of the
          ``connectFromField`` with which to start the recursive
          search.

      * - ``connectToField``

        - Field name in other document against which to match the
          ``connectToField``.

      * - ``as``

        - Field name of the array field added to each output document
          that contains the documents traversed in the
          :pipeline:`$graphLookup` stage for the document.

      * - ``maxDepth``
        - Non-negative integral number that specifies the maximum
          recursive depth.

      * - ``depthField`` 

        - *Optional.* Name of the field to add to each traversed
          document in the search path. The field holds the recursion depth for
          the document. Depth value starts at zero; i.e. the first
          lookup corresponds to zero depth.

      * - ``restrictSearchWithMatch``

        - A document that specifies additional condition for the
          recursive search. The syntax is identical to the :ref:`query
          filter <read-operations-query-argument>` syntax.

   .. COMMENT to DocsTeam: Be sure to include an example using the 'restrictSearchByMatch'
   
   Consider a collection ``employees`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "name" : "Dev" }
      { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
      { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }
      { "_id" : 4, "name" : "Andrew", "reportsTo" : "Eliot" }
      { "_id" : 5, "name" : "Asya", "reportsTo" : "Ron" }
      { "_id" : 6, "name" : "Dan", "reportsTo" : "Andrew" }

   The following :pipeline:`$graphLookup` operation traverses the
   documents in the collection to recursively match on the
   ``reportsTo`` and ``name`` to return the reporting hierarchy for
   each person:

   .. code-block:: javascript

      db.employees.aggregate( [
         {
            $graphLookup: {
               from: "employees",
               startWith: "$reportsTo",
               connectFromField: "reportsTo",
               connectToField: "name",
               as: "reportingHierarchy"
            }
         }
      ] )
   
   The operation returns the following documents:
   
   .. code-block:: javascript
   
      { "_id" : 1, "name" : "Dev", "reportingHierarchy" : [ ] }
      {
      
         "_id" : 2,
         "name" : "Eliot",
         "reportsTo" : "Dev",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" }
         ]
      }
      {
         "_id" : 3,
         "name" : "Ron",
         "reportsTo" : "Eliot",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
         ]
      }
      {
         "_id" : 4,
         "name" : "Andrew",
         "reportsTo" : "Eliot",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
         ]
      }
      {
         "_id" : 5,
         "name" : "Asya",
         "reportsTo" : "Ron",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" },
            { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }
         ]
      }
      {
         "_id" : 6,
         "name" : "Dan",
         "reportsTo" : "Andrew",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" },
            { "_id" : 4, "name" : "Andrew", "reportsTo" : "Eliot" }
         ]
      }

   The following table provides a traversal path for operation for the
   document ``{ "_id" : 5, "name" : "Asya", "reportsTo" : "Ron" }``:

   .. list-table::
      :stub-columns: 1

      * - Start value

        - The ``reportsTo`` value of the document:

          .. code-block:: javascript

             { ... "reportsTo" : "Ron" }

      * - Depth 0

        - .. code-block:: javascript

             { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }

      * - Depth 1

        - .. code-block:: javascript

             { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }

      * - Depth 2
         
        - .. code-block:: javascript

             { "_id" : 1, "name" : "Dev" }
   
   
   Similar to :pipeline:`$lookup`, :pipeline:`$graphLookup` can access
   another collection in the same database. For example, a database
   contains the following collections:

   - A collection ``airports`` that contains the following documents:

     .. code-block:: javascript

        { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ] }
        { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ] }
        { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ] }
        { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ] }
        { "_id" : 4, "airport" : "LHR", "connects" : [ "PWM" ] }

   - A collection ``travelers`` that contains the following documents:

     .. code-block:: javascript

        { "_id" : 1, "name" : "Dev", "nearestAirport" : "JFK" }
        { "_id" : 2, "name" : "Eliot", "nearestAirport" : "JFK" }
        { "_id" : 3, "name" : "Jeff", "nearestAirport" : "BOS" }

   For each document in the ``travelers`` collection, the following
   operation looks up a the ``nearestAirport`` value in the
   ``airports`` collection, and recursively matches the ``connects``
   field to the ``airport`` fields in documents in the ``airports``
   collection. The operation specifies a maximum number of recursion to
   ``2``.

   .. code-block:: javascript

      db.travelers.aggregate( [
         {
            $graphLookup: {
               from: "airports",
               startWith: "$nearestAirport",
               connectFromField: "connects",
               connectToField: "airport",
               maxDepth: 2,
               depthField: "numConnections",
               as: "destinations"
            }
         }
      ] )

   The operation returns the following results:
   
   .. code-block:: javascript
   
      {
         "_id" : 1,
         "name" : "Dev",
         "nearestAirport" : "JFK",
         "destinations" : [
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(2) },
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(1) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(0) }
         ] 
      }
      {
         "_id" : 2,
         "name" : "Eliot",
         "nearestAirport" : "JFK",
         "destinations" : [ 
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(2) },
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(1) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(0) } ]
      }
      {
         "_id" : 3,
         "name" : "Jeff",
         "nearestAirport" : "BOS",
         "destinations" : [
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(2) },
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(1) },
            { "_id" : 4, "airport" : "LHR", "connects" : [ "PWM" ], "numConnections" : NumberLong(2) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(0) }
         ]
      }
   
   The following table provides a traversal path for the recursive
   search, up to depth 2, where the starting ``airport`` is ``JFK``:

   .. list-table::
      :stub-columns: 1

      * - Start value

        - The ``nearestAirport`` value from the ``travelers`` collection:

          .. code-block:: javascript

             { ... "nearestAirport" : "JFK" }

      * - Depth 0

        - .. code-block:: javascript

             { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ] }

      * - Depth 1

        - .. code-block:: javascript

             { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ] }
             { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ] }
            
      * - Depth 2
         
        - .. code-block:: javascript

             { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ] }

   .. seealso:: :ref:`agg-memory-restrictions`

New Array Operators
~~~~~~~~~~~~~~~~~~~~

MongoDB 3.4 release candidate introduces the following new array
operators for the aggregation framework:

.. expression:: $in

   Returns a boolean that indicates if a specified value is in an array.

   :expression:`$in` has the following :ref:`operator expression syntax
   <agg-quick-ref-operator-expressions>`:

   .. code-block:: javascript

      { $in: [ <expression>, <array expression> ] }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.

   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Operand
        - Description

      * - ``<expression>`` 

        - Any valid expression :ref:`expression
          <aggregation-expressions>`.

      * - ``<array expression>`` 

        - Any valid :ref:`expression <aggregation-expressions>` that
          resolves to an array.

   Unlike the :query:`$in` query operator which can support
   :ref:`regular expressions <query-in-regex>` to match values, the
   aggregation :expression:`$in` operator does not support matching by
   :ref:`regular expressions <query-in-regex>`.

   .. list-table::
      :header-rows: 1
      :widths: 95 5

      * - Example
        - Results

      * - ``{ $in: [ 2, [ 1, 2, 3 ] ] }``
        - ``true``

      * - ``{ $in: [ "abc", [ "xyz", "abc" ] ] }``
        - ``true``

      * - ``{ $in: [ "xy", [ "xyz", "abc" ] ] }``
        - ``false``

      * - ``{ $in: [ ["a"], [ "a" ] ] }``
        - ``false``

      * - ``{ $in: [ ["a"], [ ["a"] ] ] }``
        - ``true``

      * - ``{ $in: [ /^a/, [ "a" ] ] }``
        - ``false``

      * - ``{ $in: [ /^a/, [ "a" ] ] }``
        - ``false``

      * - ``{ $in: [ /^a/, [ /^a/ ] ] }``
        - ``true``

New String Operators
~~~~~~~~~~~~~~~~~~~~

MongoDB 3.4 release candidate introduces the following new string
operators for the aggregation framework:

New Control Flow Expression
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. expression:: $switch

   Evaluates, in sequential order, the ``case`` expressions of the
   specified branches to enter the first branch for which the ``case``
   expression evaluates to ``true``. The :expression:`$switch` operator
   executes the ``then`` expression for that branch and breaks out of
   the control flow.

   :expression:`$switch` has the following syntax:

   .. code-block:: javascript

      $switch: {
         branches: [
            { case: <expression>, then: <expression> },
            { case: <expression>, then: <expression> },
            ...
         ],
         default: <expression>
      }

   .. COMMENT to DocsTeam: in 3.4 manual, should use the args yaml file as usual.
   .. COMMENT to DocsTeam: We're using integral number below instead of
      integer since we can pass in 1.0 or 2.0 etc and they would work


   .. list-table::
      :header-rows: 1
      :widths: 30 65

      * - Operand
        - Description

      * - ``branches``

        - An array of control branch documents. Each branch is a
          document with the following fields:

          - ``case``
               The argument can be any valid :ref:`expression
               <aggregation-expressions>` that resolve to a boolean.
                         
          - ``then``
               The argument can be any valid :ref:`expression
               <aggregation-expressions>`.

          The ``branches`` array must contain at least one branch
          document.

      * - ``default``

        - Optional. The path to take if no branch ``case`` expression
          evaluates to ``true``.
          
          Although optional, if ``default`` is unspecified and no
          branch ``case`` evaluates to true, :expression:`$switch`
          returns an error.


   .. list-table::
      :header-rows: 1
      :widths: 80 20

      * - Example
        - Results

      * - .. code-block:: javascript

             {
                $switch: {
                   branches: [
                      { case: { $eq: [ 0, 5 ] }, then: "equals" },
                      { case: { $gt: [ 0, 5 ] }, then: "greater than" },
                      { case: { $lt: [ 0, 5 ] }, then: "less than" }
                   ]
                }
             }
             
        - ``"less than"``

      * - .. code-block:: javascript

             {
                $switch: {
                   branches: [ 
                      { case: { $eq: [ 0, 5 ] }, then: "equals" },
                      { case: { $gt: [ 0, 5 ] }, then: "greater than" }
                   ],
                   default: "Did not match"
                }
             }
             
        - ``"Did not match"``

