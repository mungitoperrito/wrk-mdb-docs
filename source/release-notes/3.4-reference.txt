:orphan:

===============================
3.4 Release Candidate Reference
===============================

.. default-domain:: mongodb

.. include:: /includes/3.4.rst

See also :doc:`/release-notes/3.4`.

Aggregation Framework Enhancements
----------------------------------

New Stages
~~~~~~~~~~

MongoDB 3.4 release candidate introduces the following new
:ref:`aggregation pipeline stages <aggregation-pipeline>`.

.. pipeline:: $graphLookup

   Performs a recursive search on a collection. The stage matches the
   ``connectFromField`` of one document to the ``connectToField`` of
   other documents in the collection. Then, for any matching document,
   the :pipeline:`$graphLookup` uses the ``connectFromField`` of the
   matching document to match to the the ``connectToField`` of other
   documents, and continues until no new documents are encountered or
   until a specified depth. To each output document, the
   :pipeline:`$graphLookup` adds a new array field that contains the
   traversal results of the recursive search for that document.

   The :pipeline:`$graphLookup` stage has the following form:

   .. code-block:: javascript

      {
         $graphLookup: {
            from: <collection>,
            connectToField: <string>,
            startWith: <expression>,
            connectFromField: <string>,
            as: <string>,
            maxDepth: <number>,
            depthField: <string>,
            restrictSearchWithMatch: <document>
         }
      }

   .. list-table::
      :header-rows: 1
      :widths: 40 60

      * - Field
        - Description

      * - ``from``

        - Collection on whose documents to perfrom
          :pipeline:`$graphLookup`, recursively matching on the
          ``connectFromField`` to the ``connectToField``.

          The ``from`` collection cannot be sharded.

      * - ``connectFromField``

        - Field name whose value :pipeline:`$graphLookup` uses to
          recursively match against the ``connectToField`` of other
          documents in the collection.

      * - ``startWith``

        - Expression that specifies the value of the
          ``connectFromField`` with which to start the recursive
          search.

      * - ``connectToField``

        - Field name in other document against which to match the
          ``connectToField``.

      * - ``as``

        - Field name of the array field added to each output document
          that contains the documents traversed in the
          :pipeline:`$graphLookup` stage for the document.

      * - ``maxDepth``
        - Non-negative integral number that specifies the maximum
          recursive depth.

      * - ``depthField`` 

        - *Optional.* Name of the field to add to each traversed
          document in the search path. The field holds the recursion depth for
          the document. Depth value starts at zero; i.e. the first
          lookup corresponds to zero depth.

      * - ``restrictSearchWithMatch``

        - A document that specifies additional condition for the
          recursive search. The syntax is identical to the :ref:`query
          filter <read-operations-query-argument>` syntax.

   .. COMMENT to DocsTeam: Be sure to include an example using the 'restrictSearchByMatch'
   
   Consider a collection ``employees`` with the following documents:

   .. code-block:: javascript

      { "_id" : 1, "name" : "Dev" }
      { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
      { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }
      { "_id" : 4, "name" : "Andrew", "reportsTo" : "Eliot" }
      { "_id" : 5, "name" : "Asya", "reportsTo" : "Ron" }
      { "_id" : 6, "name" : "Dan", "reportsTo" : "Andrew" }

   The following :pipeline:`$graphLookup` operation traverses the
   documents in the collection to recursively match on the
   ``reportsTo`` and ``name`` to return the reporting hierarchy for
   each person:

   .. code-block:: javascript

      db.employees.aggregate( [
         {
            $graphLookup: {
               from: "employees",
               startWith: "$reportsTo",
               connectFromField: "reportsTo",
               connectToField: "name",
               as: "reportingHierarchy"
            }
         }
      ] )
   
   The operation returns the following documents:
   
   .. code-block:: javascript
   
      { "_id" : 1, "name" : "Dev", "reportingHierarchy" : [ ] }
      {
      
         "_id" : 2,
         "name" : "Eliot",
         "reportsTo" : "Dev",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" }
         ]
      }
      {
         "_id" : 3,
         "name" : "Ron",
         "reportsTo" : "Eliot",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
         ]
      }
      {
         "_id" : 4,
         "name" : "Andrew",
         "reportsTo" : "Eliot",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }
         ]
      }
      {
         "_id" : 5,
         "name" : "Asya",
         "reportsTo" : "Ron",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" },
            { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }
         ]
      }
      {
         "_id" : 6,
         "name" : "Dan",
         "reportsTo" : "Andrew",
         "reportingHierarchy" : [
            { "_id" : 1, "name" : "Dev" },
            { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" },
            { "_id" : 4, "name" : "Andrew", "reportsTo" : "Eliot" }
         ]
      }

   The following table provides a traversal path for operation for the
   document ``{ "_id" : 5, "name" : "Asya", "reportsTo" : "Ron" }``:

   .. list-table::
      :stub-columns: 1

      * - Start value

        - The ``reportsTo`` value of the document:

          .. code-block:: javascript

             { ... "reportsTo" : "Ron" }

      * - Depth 0

        - .. code-block:: javascript

             { "_id" : 3, "name" : "Ron", "reportsTo" : "Eliot" }

      * - Depth 1

        - .. code-block:: javascript

             { "_id" : 2, "name" : "Eliot", "reportsTo" : "Dev" }

      * - Depth 2
         
        - .. code-block:: javascript

             { "_id" : 1, "name" : "Dev" }
   
   
   Similar to :pipeline:`$lookup`, :pipeline:`$graphLookup` can access
   another collection in the same database. For example, a database
   contains the following collections:

   - A collection ``airports`` that contains the following documents:

     .. code-block:: javascript

        { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ] }
        { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ] }
        { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ] }
        { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ] }
        { "_id" : 4, "airport" : "LHR", "connects" : [ "PWM" ] }

   - A collection ``travelers`` that contains the following documents:

     .. code-block:: javascript

        { "_id" : 1, "name" : "Dev", "nearestAirport" : "JFK" }
        { "_id" : 2, "name" : "Eliot", "nearestAirport" : "JFK" }
        { "_id" : 3, "name" : "Jeff", "nearestAirport" : "BOS" }

   For each document in the ``travelers`` collection, the following
   operation looks up a the ``nearestAirport`` value in the
   ``airports`` collection, and recursively matches the ``connects``
   field to the ``airport`` fields in documents in the ``airports``
   collection. The operation specifies a maximum number of recursion to
   ``2``.

   .. code-block:: javascript

      db.travelers.aggregate( [
         {
            $graphLookup: {
               from: "airports",
               startWith: "$nearestAirport",
               connectFromField: "connects",
               connectToField: "airport",
               maxDepth: 2,
               depthField: "numConnections",
               as: "destinations"
            }
         }
      ] )

   The operation returns the following results:
   
   .. code-block:: javascript
   
      {
         "_id" : 1,
         "name" : "Dev",
         "nearestAirport" : "JFK",
         "destinations" : [
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(2) },
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(1) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(0) }
         ] 
      }
      {
         "_id" : 2,
         "name" : "Eliot",
         "nearestAirport" : "JFK",
         "destinations" : [ 
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(2) },
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(1) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(0) } ]
      }
      {
         "_id" : 3,
         "name" : "Jeff",
         "nearestAirport" : "BOS",
         "destinations" : [
            { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ], "numConnections" : NumberLong(2) },
            { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ], "numConnections" : NumberLong(1) },
            { "_id" : 4, "airport" : "LHR", "connects" : [ "PWM" ], "numConnections" : NumberLong(2) },
            { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ], "numConnections" : NumberLong(1) },
            { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ], "numConnections" : NumberLong(0) }
         ]
      }
   
   The following table provides a traversal path for the recursive
   search, up to depth 2, where the starting ``airport`` is ``JFK``:

   .. list-table::
      :stub-columns: 1

      * - Start value

        - The ``nearestAirport`` value from the ``travelers`` collection:

          .. code-block:: javascript

             { ... "nearestAirport" : "JFK" }

      * - Depth 0

        - .. code-block:: javascript

             { "_id" : 0, "airport" : "JFK", "connects" : [ "BOS", "ORD" ] }

      * - Depth 1

        - .. code-block:: javascript

             { "_id" : 1, "airport" : "BOS", "connects" : [ "JFK", "PWM" ] }
             { "_id" : 2, "airport" : "ORD", "connects" : [ "JFK" ] }
            
      * - Depth 2
         
        - .. code-block:: javascript

             { "_id" : 3, "airport" : "PWM", "connects" : [ "BOS", "LHR" ] }

   .. seealso:: :ref:`agg-memory-restrictions`

